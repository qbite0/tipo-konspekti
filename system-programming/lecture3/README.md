---
начат: 07.09.2022
закончен: 08.09.2022
тема: Синхронизация потоков с использованием объекта ядра
---

# Синхронизация потоков с использованием объекта ядра

Критические секции, подходят для синхронизации потоков одного процесса. Задачу синхронизации потоков различных процессов принято решать с помощью объектов ядра. Объекту ядра может быть присвоено имя, они позволяют задавать тайм-аут для времени ожидания и обладают еще рядом возможностей для реализации гибких сценариев синхронизации. Однако их использование связано с переходом в режим ядра (примерно 1000 тактов процессора), то есть они работают несколько медленнее, нежели критические секции.

Почти все объекты ядра, рассмотренные ранее, в том числе, процессы, потоки и файлы, пригодны для решения задач синхронизации. В контексте задач синхронизации о каждом из объектов можно сказать, находится ли он в свободном (сигнальном, signaled state) или занятом (nonsignaled state) состоянии. Правила перехода объекта из одного состояния в другое зависят от объекта. Например, если поток выполняется, то он находится в занятом состоянии, а если поток успешно завершил ожидание семафора, то семафор находится в занятом состоянии.

Потоки находятся в состоянии ожидания, пока ожидаемые ими объекты заняты. Как только объект освобождается, ОС будит поток и позволяет продолжить выполнение. Для приостановки потока и перевода его в состояние ожидания освобождения объекта используется функция

DWORD WaitForSingleObject(HANDLE hObject, DWORD dwMilliseconds);
где hObject - описатель ожидаемого объекта ядра, а второй параметр - максимальное время ожидания объекта.

DWORD dw = WaitForSingleObject(hProc, 5000); switch(dw){

case WAIT_OBJECT_0: //процесс успешно завершился ... //код обработки break;

case WAIT_TIMEOUT: //процесс не завершился за 5000 мс,

//ожидание прервано ... //код обработки break;

case WAIT_FAILED: //неправильный вызов функции ... // код обработки break;

Поток создает объект ядра при помощи семейства функций Create ( CreateSemaphore, CreateThread и т.д.), после чего объект посредством описателя становится доступным всем потокам данного процесса. Копия описателя может быть получена при помощи функции DuplicateHandle и передана другому процессу, после чего потоки смогут воспользоваться этим объектом для синхронизации.

Другим, более распространенным способом получения описателя является открытие существующего объекта по имени, поскольку многие объекты имеют имена в пространстве имен объектов. Имя объекта - один из параметров Create -функций. Зная имя объекта, поток, обладающий нужными правами доступа, получает его описатель с помощью Open -функций. Напомним, что в структуре, описывающей объект, имеется счетчик ссылок на него, который увеличивается на 1 при открытии объекта и уменьшается на 1 при его закрытии.

HANDLE CreateEvent(PSECURITY_ATTRIBUTES psa,BOOL fManualReset, BOOL fInitialState, PCTSTR pszName);

Функция создает объект ядра «событие».

Параметр psa указывает на настройки безопасности (как правило, здесь передается null, выше эти настройки обсуждались более подробно).

Параметр fManualReset определяет, будет ли событие со сбросом вручную (true) или с автосбросом (FALSE).

Параметр fInitialState определяет начальное состояние события - свободное (true) или занятое (false).

HANDLE OpenEvent(DWORD fdwAccess, BOOL fInherit,PCTSTR pszName);

Функция открывает объект ядра «событие». Последний параметр, pszName, определяет имя объекта ядра. Он всегда должен содержать адрес строки с нулевым символом в конце (передавать null нельзя). Функции OpenHandle () просматривают единое пространство имен объектов ядра, пытаясь найти совпадение. Если объекта ядра «событие» с указанным именем нет или он другого типа, Open-функции возвращают null. Но если объект ядра «событие» с заданным именем существует, система проверяет, разрешен ли к данному объекту доступ запрошенного (через параметр fdwAccess) вида. Если доступ разрешен, таблица описателей в вызывающем процессе обновляется, и счетчик числа пользователей объекта возрастает на единицу. Если присвоить параметру finherit значение true, то будет получен наследуемый описатель.

BOOL CloseHandle(HANDLE hObj);

Функция закрывает описатель hobj объекта ядра «событие».

BOOL SetEvent(HANDLE hEvent);

Функция переводит событие hEvent в свободное состояние. Если событие уже было свободно, то никаких действий функция не производит.

BOOL ResetEvent(HANDLE hEvent);

Функция переводит событие hEvent в занятое состояние.